La interpretación del código es algo compleja. Básicamente se crea una matriz dinámica de dimensión definida en tiempo de ejecución y formada por estructuras de campos de bit que ocupan 1 byte en memoria. Existen dos algoritmos de creación del laberinto: el algoritmo inverso y el algoritmo directo (como yo los he bautizado):

- Ambos algoritmos tienen algo en común: entre dos puntos cualesquiera del laberinto existe siempre una y sólo una solución posible.
- Algoritmo directo: genera a partir de un punto caminos de forma aleatoria en todas direcciones hasta llenar por completo la matriz. A partir de ahí, definiendo los puntos de inicio y final del 	recorrido que deseemos, busca por ensayo y error la solución única y la marca. Este algoritmo es mucho más rápido, pero como inconveniente tiene que la solución del laberinto entre dos puntos cualesquiera tiende a ser la recta entre ambos. La búsqueda de esta solución es, en relación al tiempo de creación del laberinto, prácticamente instantánea. Este algoritmo es conveniente para laberintos de gran tamaño (para agilizar la creación de la matriz) o muy pequeños (para que el camino solución ocupe una parte mayor del laberinto).
- Algoritmo inverso: este algoritmo es más lento que el anterior ya que en primer lugar, crea el camino solución del laberinto. Al hacer que éste sea totalmente aleatorio en su recorrido, la probabilidad de encerrarse antes de llevar acabo su objetivo es muy alta, por ello están los parámetros "n_retrocesos", "l_retroceso", etc... que optimizan la rectificación de estos errores en la ejecución. Tras crear el recorrido principal, el resto del laberinto se rellena de forma instantánea con un procedimiento igual al del algoritmo directo. No es aconsejable utilizar este algoritmo para laberintos de más de 150000 casillas, ya que puede tardar unos 7 segundos de media en un pentium IV. Otra de sus características es que la longitud de la solución está determinada por el área según el parámetro "p_libre_nivel1", asegurándote que va a ocupar la solución un 10% del área del laberinto (cosa que no pasa ni por asomo en laberintos de gran tamaño creados mediante el algoritmo directo).

Para modificar los parámetros posición inicial y final en la resolución del laberinto por el método directo se ha de modificar la línea 847:

    847:    p_cartes pos_inicio = {0, 0}, pos_fin = {dim.x-1, dim.y-1};
